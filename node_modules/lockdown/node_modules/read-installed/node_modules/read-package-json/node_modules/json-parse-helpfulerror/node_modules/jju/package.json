{
  "name": "jju",
  "version": "1.2.0",
  "description": "a set of utilities to work with JSON / JSON5 documents",
  "author": {
    "name": "Alex Kocharin",
    "email": "alex@kocharin.ru"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/rlidwka/jju"
  },
  "bugs": {
    "url": "https://github.com/rlidwka/jju/issues"
  },
  "homepage": "http://rlidwka.github.io/jju/",
  "devDependencies": {
    "mocha": ">=1.21.0",
    "js-yaml": ">=3.1.0",
    "eslint": "~0.4.2"
  },
  "scripts": {
    "test": "mocha test/*.js",
    "lint": "eslint -c ./.eslint.yaml ./lib"
  },
  "keywords": [
    "json",
    "json5",
    "parser",
    "serializer",
    "data"
  ],
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "license": {
    "type": "WTFPL",
    "url": "http://www.wtfpl.net/txt/copying/"
  },
  "readme": "`jju` - a set of utilities to work with JSON / JSON5 documents\n\n[![npm version badge](https://img.shields.io/npm/v/jju.svg)](https://www.npmjs.org/package/jju)\n[![travis badge](http://img.shields.io/travis/rlidwka/jju.svg)](https://travis-ci.org/rlidwka/jju)\n[![downloads badge](http://img.shields.io/npm/dm/jju.svg)](https://www.npmjs.org/package/jju)\n\n## Installation\n\n```\nnpm install jju\n```\n\n## Usage\n\nThis module provides following functions:\n\n1. [jju.parse()](#jjuparse-function) parses json/json5 text and returns a javascript value it corresponds to\n2. [jju.stringify()](#jjustringify-function) converts javascript value to an appropriate json/json5 text\n3. [jju.tokenize()](#jjutokenize-function) parses json/json5 text and returns an array of tokens it consists of ([see demo](http://rlidwka.github.io/jju/tokenizer.html))\n4. [jju.analyze()](#jjuanalyze-function) parses json/json5 text and tries to guess indentation, quoting style, etc.\n5. [jju.update()](#jjuupdate-function) changes json/json5 text, preserving original formatting as much as possible ([see demo](http://rlidwka.github.io/jju/editor.html))\n\nAll functions are able to work with a standard JSON documents. `jju.parse()` and `jju.stringify()` are better in some cases, but slower than native `JSON.parse()` and `JSON.stringify()` versions. Detailed description see below.\n\n### jju.parse() function\n\n```javascript\n/*\n * Main syntax:\n *\n * `text` - text to parse, type: String\n * `options` - parser options, type: Object\n */\njju.parse(text[, options])\n\n// compatibility syntax\njju.parse(text[, reviver])\n```\n\nOptions:\n\n - reserved\\_keys - what to do with reserved keys (String, default=\"ignore\")\n   - \"ignore\" - ignore reserved keys\n   - \"throw\" - throw SyntaxError in case of reserved keys\n   - \"replace\" - replace reserved keys, this is the default JSON.parse behaviour, unsafe\n\n     Reserved keys are keys that exist in an empty object (`hasOwnProperty`, `__proto__`, etc.).\n\n```javascript\n// 'ignore' will cause reserved keys to be ignored:\nparse('{hasOwnProperty: 1}', {reserved_keys: 'ignore'}) == {}\nparse('{hasOwnProperty: 1, x: 2}', {reserved_keys: 'ignore'}).hasOwnProperty('x') == true\n\n// 'throw' will cause SyntaxError in these cases:\nparse('{hasOwnProperty: 1}', {reserved_keys: 'throw'}) == SyntaxError\n\n// 'replace' will replace reserved keys with new ones:\nparse('{hasOwnProperty: 1}', {reserved_keys: 'throw'}) == {hasOwnProperty: 1}\nparse('{hasOwnProperty: 1, x: 2}', {reserved_keys: 'ignore'}).hasOwnProperty('x') == TypeError\n```\n\n\n - null\\_prototype - create object as Object.create(null) instead of '{}' (Boolean)\n\n   if `reserved_keys != 'replace'`, default is **false**\n\n   if `reserved_keys == 'replace'`, default is **true**\n\n   It is usually unsafe and not recommended to change this option to false in the last case.\n\n - reviver - reviver function - Function\n\n   This function should follow JSON specification\n\n - mode - operation mode, set it to 'json' if you want to throw on non-strict json files (String)\n\n### jju.stringify() function\n\n```javascript\n/*\n * Main syntax:\n *\n * `value` - value to serialize, type: *\n * `options` - serializer options, type: Object\n */\njju.stringify(value[, options])\n\n// compatibility syntax\njju.stringify(value[, replacer [, indent])\n```\n\nOptions:\n\n - ascii - output ascii only (Boolean, default=false)\n   If this option is enabled, output will not have any characters except of 0x20-0x7f.\n\n - indent - indentation (String, Number or Boolean, default='\\t')\n   This option follows JSON specification.\n\n - quote - enquoting char (String, \"'\" or '\"', default=\"'\")\n - quote\\_keys - whether keys quoting in objects is required or not (String, default=false)\n   If you want `{\"q\": 1}` instead of `{q: 1}`, set it to true.\n\n - sort\\_keys - sort all keys while stringifying (Boolean or Function, default=false)\n   By default sort order will depend on implementation, with v8 it's insertion order. If set to `true`, all keys (but not arrays) will be sorted alphabetically. You can provide your own sorting function as well.\n\n - replacer - replacer function or array (Function or Array)\n   This option follows JSON specification.\n\n - no\\_trailing\\_comma = don't output trailing comma (Boolean, default=false)\n   If this option is set, arrays like this `[1,2,3,]` will never be generated. Otherwise they may be generated for pretty printing.\n\n - mode - operation mode, set it to 'json' if you want correct json in the output (String)\n\n   Currently it's either 'json' or something else. If it is 'json', following options are implied:\n\n   - options.quote = '\"'\n   - options.no\\_trailing\\_comma = true\n   - options.quote\\_keys = true\n   - '\\x' literals are not used\n\n### jju.tokenize() function\n\n```javascript\n/*\n * Main syntax:\n *\n * `text` - text to tokenize, type: String\n * `options` - parser options, type: Object\n */\njju.tokenize(text[, options])\n```\n\nOptions are the same as for the `jju.parse` function.\n\nReturn value is an array of tokens, where each token is an object:\n\n - raw (String) - raw text of this token, if you join all raw's, you will get the original document\n - type (String) - type of the token, can be `whitespace`, `comment`, `key`, `literal`, `separator` or `newline`\n - stack (Array) - path to the current token in the syntax tree\n - value - value of the token if token is a `key` or `literal`\n\nYou can check tokenizer for yourself using [this demo](http://rlidwka.github.io/jju/tokenizer.html).\n\n### jju.analyze() function\n\n```javascript\n/*\n * Main syntax:\n *\n * `text` - text to analyze, type: String\n * `options` - parser options, type: Object\n */\njju.analyze(text[, options])\n```\n\nOptions are the same as for the `jju.parse` function.\n\nReturn value is an object defining a programming style in which the document was written.\n\n - indent (String) - preferred indentation\n - newline (String) - preferred newline\n - quote (String) - `\"` or `'` depending on which quote is preferred\n - quote\\_keys (Boolean) - `true` if unquoted keys were used at least once\n - has\\_whitespace (Boolean) - `true` if input has a whitespace token\n - has\\_comments (Boolean) - `true` if input has a comment token\n - has\\_newlines (Boolean) - `true` if input has a newline token\n - has\\_trailing\\_comma (Boolean) - `true` if input has at least one trailing comma\n\n### jju.update() function\n\n```javascript\n/*\n * Main syntax:\n *\n * `text` - original text, type: String\n * `new_value` - new value you want to set\n * `options` - parser or stringifier options, type: Object\n */\njju.update(text, new_value[, options])\n```\n\nIf you want to update a JSON document, here is the general approach:\n\n```javascript\n// here is your original JSON document:\nvar input = '{\"foo\": \"bar\", \"baz\": 123}'\n\n// you need to parse it first:\nvar json = jju.parse(input, {mode: 'json'})\n// json is { foo: 'bar', baz: 123 }\n\n// then you can change it as you like:\njson.foo = 'quux'\njson.hello = 'world'\n\n// then you run an update function to change the original json:\nvar output = jju.update(input, json, {mode: 'json'})\n// output is '{\"foo\": \"quux\", \"baz\": 123, \"hello\": \"world\"}'\n```\n\nLook at [this demo](http://rlidwka.github.io/jju/editor.html) to test various types of json.\n\n## Advantages over existing JSON libraries\n\nIn a few cases it makes sense to use this module instead of built-in JSON methods.\n\nParser:\n - better error reporting with source code and line numbers\n\nIn case of syntax error, JSON.parse does not return any good information to the user. This module does:\n\n```\n$ node -e 'require(\"jju\").parse(\"[1,1,1,1,invalid]\")'\n\nSyntaxError: Unexpected token 'i' at 0:9\n[1,1,1,1,invalid]\n         ^\n```\n\nThis module is about 5 times slower, so if user experience matters to you more than performance, use this module. If you're working with a lot of machine-generated data, use JSON.parse instead.\n\nStringifier:\n - util.inspect-like pretty printing\n\nThis module behaves more smart when dealing with object and arrays, and does not always print newlines in them:\n\n```\n$ node -e 'console.log(require(\"./\").stringify([[,,,],,,[,,,,]], {mode:\"json\"}))'\n[\n        [null, null, null],\n        null,\n        null,\n        [null, null, null, null]\n]\n```\n\nJSON.stringify will split this into 15 lines, and it's hard to read.\n\nYet again, this feature comes with a performance hit, so if user experience matters to you more than performance, use this module. If your JSON will be consumed by machines, use JSON.stringify instead.\n\nAs a rule of thumb, if you use \"space\" argument to indent your JSON, you'd better use this module instead.\n\n",
  "readmeFilename": "README.md",
  "_id": "jju@1.2.0",
  "dist": {
    "shasum": "23b9bd2c17b20a228dd86820707b9f90e1cdb6b6"
  },
  "_from": "jju@^1.1.0",
  "_resolved": "https://registry.npmjs.org/jju/-/jju-1.2.0.tgz"
}
