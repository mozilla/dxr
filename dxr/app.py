import os.path
from os.path import isdir
from sqlite3 import OperationalError
from time import time

from flask import (Blueprint, Flask, send_from_directory, current_app, escape,
                   send_file, request, redirect, jsonify, render_template)

from dxr.query import Query, direct_result, fetch_results
from dxr.server_utils import connect_db


# Look in the 'dxr' package for static files, templates, etc.:
dxr_blueprint = Blueprint('dxr_blueprint', 'dxr')


def make_app(instance_path):
    """Return a DXR application which looks in the given folder for
    configuration.

    Also set up the static and template folder according to the configured
    template.

    """
    # TODO: Actually obey the template selection in the config file by passing
    # a different static_folder and template_folder to Flask().
    app = Flask('dxr', instance_path=instance_path)
    app.register_blueprint(dxr_blueprint)

    # Load the special config file generated by dxr-build:
    app.config.from_pyfile(os.path.join(app.instance_path, 'config.py'))
    return app


@dxr_blueprint.route('/')
def index():
    return send_file(current_app.open_instance_resource('trees/index.html'))


@dxr_blueprint.route('/search')
def search():
    """Search by regex, caller, superclass, or whatever."""
    # TODO: This ugly mess is marring the rest of this file. Rewrite it.

    # Load query parameters
    querystring = request.values

    # Get output format
    output_format = querystring.get("format", "html")
    if output_format not in ("html", "json"):
        output_format = "html"

    # Decide if we can redirect
    can_redirect = querystring.get("redirect", "true") == "true"

    # Find the offset and limit
    # TODO Handle parsing errors that could occur here
    offset = int(querystring.get("offset", 0))
    limit = int(querystring.get("limit", 100))

    # Get and validate tree
    tree = querystring.get('tree')
    config = current_app.config
    if tree not in config['TREES']:
        # Arguments for the template
        arguments = {
            # Common Template Variables
            "wwwroot": config['WWW_ROOT'],
            "tree": config['TREES'][0],
            "trees": config['TREES'],
            "generated_date": config['GENERATED_DATE'],
            "config": config['TEMPLATE_PARAMETERS'],
            # Error template Variables
            "error": "Tree '%s' is not a valid tree." % tree
        }
        template = "error.html"
    else:
        # Parse the search query
        qtext = querystring.get("q", "").decode('utf-8')
        q = Query(qtext)
        # Connect to database
        conn = connect_db(tree, current_app.instance_path)
        # Arguments for the template
        arguments = {
            # Common Template Variables
            "wwwroot": config['WWW_ROOT'],
            "tree": tree,
            "trees": config['TREES'],
            "config": config['TEMPLATE_PARAMETERS'],
            "generated_date": config['GENERATED_DATE']
        }
        if conn:
            result = None
            if can_redirect:
                result = direct_result(conn, q)
            if result:
                path, line = result
                # TODO: Does this escape qtext properly?
                return redirect('%s/%s/%s?from=%s#l%i' %
                                (config['WWW_ROOT'], tree, path, qtext, line))
            # Okay let's try to make search results
            template = "search.html"
            # Catching any errors from sqlite, typically, regexp errors
            error = None
            start = time()
            try:
                results = list(fetch_results(
                    conn, q,
                    offset, limit,
                    querystring.has_key("explain")
                ))
            except OperationalError, e:
                if e.message.startswith("REGEXP:"):
                    arguments["error"] = e.message[7:]
                    results = []
                elif e.message.startswith("QUERY:"):
                    arguments["error"] = e.message[6:]
                    results = []
                else:
                    arguments["error"] = "Database error '%s'" % e.message
                    template = "error.html"
            if template == "search.html":
                # Search Template Variables
                arguments["query"] = escape(qtext)
                arguments["results"] = results
                arguments["offset"] = offset
                arguments["limit"] = limit
                arguments["time"] = time() - start
        else:
            arguments["error"] = "Failed to establish database connection."
            template = "error.html"

    # If json is specified output as json
    if output_format == "json":
        #TODO Return 503 if template == "error.html"
        # Tuples are encoded as lists in JSON, and these are not real
        # easy to unpack or read in Javascript. So for ease of use, we
        # convert to dictionaries before returning the json results.
        # If further discrepancies are introduced please document them in
        # templating.mkd
        arguments["results"] = [
            {
                "icon": icon,
                "path": path,
                "lines": [{"line_number": nb, "line": l} for nb, l in lines]
            } for icon, path, lines in arguments["results"]
        ]
        return jsonify(arguments)

    # Get search template and dump it to stdout
    return render_template(template, **arguments)


@dxr_blueprint.route('/<path:tree_and_path>')
def browse(tree_and_path):
    """Show a directory listing or a single file from one of the trees."""
    tree, _, path = tree_and_path.partition('/')
    tree_folder = os.path.join(current_app.instance_path, 'trees', tree)

    if isdir(os.path.join(tree_folder, path)):
        # It's a bare directory. Add the index file to the end:
        path = os.path.join(path, current_app.config['DIRECTORY_INDEX'])
    else:
        # It's a file. Add the .html extension:
        path += '.html'

    return send_from_directory(tree_folder, path)
